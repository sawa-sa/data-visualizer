<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Marker Based AR (軽量化版)</title>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/110/three.js"></script>
    <!-- AR.js -->
    <script src="https://raw.githack.com/AR-js-org/AR.js/3.1.0/three.js/build/ar.js"></script>
    <!-- CSV Manager (別ファイルで用意) -->
    <script src="./CSVManager2.js" type="module"></script>
  </head>

  <body>
    <script type="module">
      import {
        loadCSVData,
        parseCSV,
        normalizeData,
        calculateMinMax
      } from "./CSVManager2.js";

      // =====================
      // メイン関数 (非同期)
      // =====================
      async function main() {
        // ★ 1) Three.js Renderer 設定
        const renderer = new THREE.WebGLRenderer({
          antialias: true,
          alpha: true
        });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // シーンとカメラ
        const scene = new THREE.Scene();
        const camera = new THREE.Camera();
        scene.add(camera);

        // 環境光 & 指向性ライト
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 2, 1);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        let arToolkitSource, arToolkitContext;

        // ★ 2) localStorage から データセット or CSVアップロード内容 を取得
        const chosenDataset = localStorage.getItem("chosenDataset");
        let csvText;

        if (chosenDataset === "dataset1") {
          csvText = await loadCSVData("data/dataset1.csv");
        } else if (chosenDataset === "dataset2") {
          csvText = await loadCSVData("data/dataset2.csv");
        } else if (chosenDataset === "dataset3") {
          csvText = await loadCSVData("data/dataset3.csv");
        } else if (chosenDataset === "dataset4") {
          csvText = await loadCSVData("data/dataset4.csv");
        } else if (chosenDataset === "dataset5") {
          csvText = await loadCSVData("data/dataset5.csv");
        } else {
          // カスタムアップロードCSV
          csvText = localStorage.getItem("uploadedCSVData");
          if (!csvText) {
            alert("CSVデータが見つかりません。ファイルをアップロードしてください。");
            window.location.href = "index.html";
            return;
          }
        }

        // ★ 3) AR.jsの初期化
        setupAR();

        // CSV パース
        if (!csvText) return;
        const parsedData = parseCSV(csvText);

        // 軸 & ラベル
        await addAxesWithLabels(parsedData);

        // 散布図 (SphereGeometryを軽量化)
        await createScatterPlot(parsedData);

        // レンダーループ
        function animate() {
          if (arToolkitSource.ready) {
            arToolkitContext.update(arToolkitSource.domElement);
            scene.visible = camera.visible;
          }
          renderer.render(scene, camera);
          requestAnimationFrame(animate);
        }
        animate();

        // ================
        // 関数定義群
        // ================
        function setupAR() {
          arToolkitSource = new THREEx.ArToolkitSource({ sourceType: "webcam" });
          arToolkitSource.init(() => {
            // iOSで遅延が必要な場合がある
            setTimeout(() => onResize(), 2000);
          });

          window.addEventListener("resize", onResize);

          arToolkitContext = new THREEx.ArToolkitContext({
            cameraParametersUrl: "data/camera_para.dat",
            detectionMode: "mono"
          });

          arToolkitContext.init(() => {
            camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
          });

          new THREEx.ArMarkerControls(arToolkitContext, camera, {
            type: "pattern",
            patternUrl: "data/patt.hiro",
            changeMatrixMode: "cameraTransformMatrix"
          });
        }

        function onResize() {
          arToolkitSource.onResizeElement();
          arToolkitSource.copyElementSizeTo(renderer.domElement);
          if (arToolkitContext.arController !== null) {
            arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas);
          }
        }

        async function addAxesWithLabels(parsedData) {
          const { min, max } = calculateMinMax(parsedData);

          const axisMaterial = new THREE.LineBasicMaterial({
            color: 0x888888,
            transparent: true,
            opacity: 0.5
          });

          const axes = [
            // X軸
            {
              start: [-0.5, 0, -0.5],
              end: [0.5, 0, -0.5],
              label: "X",
              minLabel: min.x,
              maxLabel: max.x,
              offset: [0.1, 0, 0]
            },
            // Y軸
            {
              start: [-0.5, 0, -0.5],
              end: [-0.5, 1, -0.5],
              label: "Y",
              minLabel: min.y,
              maxLabel: max.y,
              offset: [0, 0.1, 0]
            },
            // Z軸
            {
              start: [-0.5, 0, -0.5],
              end: [-0.5, 0, 0.5],
              label: "Z",
              minLabel: min.z,
              maxLabel: max.z,
              offset: [0, 0, 0.1]
            }
          ];

          const loader = new THREE.FontLoader();
          // ★ 4) 同一オリジンでホストしたフォントを読み込む
          loader.load("./fonts/helvetiker_regular.typeface.json", font => {
            axes.forEach(({ start, end, label, minLabel, maxLabel, offset }) => {
              // 軸
              const geometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(...start),
                new THREE.Vector3(...end)
              ]);
              const axis = new THREE.Line(geometry, axisMaterial);
              scene.add(axis);

              // ラベル用マテリアル
              const textMaterial = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.8
              });

              // 軸ラベル
              addText(scene, font, textMaterial, label, end[0] + offset[0], end[1] + offset[1], end[2] + offset[2]);
              // 最小値ラベル
              addText(scene, font, textMaterial, minLabel.toFixed(2),
                start[0] - offset[0], start[1] - offset[1], start[2] - offset[2]
              );
              // 最大値ラベル
              addText(scene, font, textMaterial, maxLabel.toFixed(2),
                end[0] + offset[0] * 2, end[1] + offset[1] * 2, end[2] + offset[2] * 2
              );
            });
          });
        }

        function addText(scene, font, material, text, x, y, z) {
          const textGeom = new THREE.TextGeometry(text, {
            font: font,
            size: 0.05,
            height: 0.01
          });
          const textMesh = new THREE.Mesh(textGeom, material);
          textMesh.position.set(x, y, z);
          scene.add(textMesh);
        }

        async function createScatterPlot(parsedData) {
          const normalizedData = normalizeData(parsedData);

          normalizedData.forEach(point => {
            const flag = localStorage.getItem("flag") || "1"; // フラグ値
            let size;
            if (flag === "1") {
              // 正規化後サイズ
              size = point.size !== undefined
                ? 0.02 + (point.size - 0.5) * 0.02
                : 0.02;
            } else {
              // 第4列をそのままスケールに
              size = point.size !== undefined
                ? 0.02 * point.size
                : 0.02;
            }

            // ★ 5) 球のセグメント数を減らして負荷を軽減
            const geometry = new THREE.SphereGeometry(size, 16, 16);
            const material = new THREE.MeshStandardMaterial({
              color: point.color,
              transparent: true,
              opacity: 0.7
            });
            const sphere = new THREE.Mesh(geometry, material);

            sphere.position.set(point.x - 0.5, point.y, point.z - 0.5);
            scene.add(sphere);
          });
        }

        // もし将来、別データを読み込む際に以前のオブジェクトを破棄したい場合の例:
        // function clearScene() {
        //   for (let i = scene.children.length - 1; i >= 0; i--) {
        //     const obj = scene.children[i];
        //     if (obj.isMesh) {
        //       obj.geometry.dispose();
        //       if (Array.isArray(obj.material)) {
        //         obj.material.forEach(m => m.dispose());
        //       } else {
        //         obj.material.dispose();
        //       }
        //     }
        //     scene.remove(obj);
        //   }
        // }

      }

      // =====================
      // メイン関数呼び出し
      // =====================
      main().catch(err => {
        console.error(err);
        alert("エラーが発生しました: " + err.message);
      });
    </script>

    <!-- キャプション表示用スクリプト -->
    <script>
      (function() {
        const flag2 = localStorage.getItem('flag2');
        if (!flag2 || (flag2 !== '1' && flag2 !== '2')) {
          return;
        }

        const captionDiv = document.createElement('div');
        captionDiv.style.position = 'absolute';
        captionDiv.style.top = '50px';
        captionDiv.style.right = '50px';
        captionDiv.style.padding = '10px';
        captionDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        captionDiv.style.border = '1px solid #ccc';
        captionDiv.style.fontSize = '14px';
        captionDiv.style.fontFamily = 'sans-serif';

        let captionText = '';
        if (flag2 === '1') {
          captionText =
            'x : bill_length_mm<br>' +
            'y : bill_depth_mm<br>' +
            'z : flipper_length_mm<br>' +
            'size : body_mass_g<br>' +
            'color : species(Adelie: 赤, Chinstrap: 青, Gentoo: 黄)';
        } else if (flag2 === '2') {
          captionText =
            'x : GDP per capita<br>' +
            'y : Life expectancy<br>' +
            'z : Surface_area_sq_km<br>' +
            'size : Population<br>' +
            'color : World Regions(ヨーロッパ: 青, アジア: 緑, アフリカ: 黄, アメリカ: 赤)';
        }

        captionDiv.innerHTML = captionText;
        document.body.appendChild(captionDiv);
      })();
    </script>
  </body>
</html>
